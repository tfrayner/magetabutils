#!/usr/bin/env perl
#
# Copyright 2008 Tim Rayner
# 
# This file is part of Bio::MAGETAB::Util.
# 
# Bio::MAGETAB::Util is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
# 
# Bio::MAGETAB::Util is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Bio::MAGETAB::Util.  If not, see <http://www.gnu.org/licenses/>.
#
# $Id$

use strict;
use warnings;

use Test::More qw(no_plan);
use Test::Exception;

use Bio::MAGETAB;

BEGIN {
    use_ok( 'Bio::MAGETAB::Util::Reader::Builder' );
}

sub confirm_method {

    my ( $builder, $method, $generated_class, $id, $attrs ) = @_;

    my $getter  = "get_$method";
    my $creator = "create_$method";
    my $finder  = "find_or_create_$method";

    if ( scalar keys %$id == 1 ) {
        dies_ok( sub{ $builder->$getter( values %$id ) },
                 qq{builder getter method doesn't find non-existent $generated_class} );
    }
    
    my $obj;
    lives_ok( sub{ $obj = $builder->$creator( { %$id, %$attrs } ) },
              qq{builder $generated_class create method succeeds} );

    ok( defined $obj, qq{and returns an object} );
    ok( $obj->isa( $generated_class ), qq{of the correct $generated_class class} );

    my $obj2;
    lives_ok( sub{ $obj2 = $builder->$finder( { %$id, %$attrs } ) },
              qq{builder $generated_class find_or_create method succeeds} );

    ok( defined $obj2, qq{and returns an object} );
    ok( $obj2->isa( $generated_class ), qq{of the correct class} );

    ok( $obj eq $obj2, qq{that is the same $generated_class object generated by the create method} );

    my $obj3 = $builder->$creator( { %$id, %$attrs } );
    ok( $obj ne $obj3,
        qq{builder create method correctly generates an entirely new $generated_class instance} );

    if ( scalar keys %$id == 1 ) {
        my $obj4;
        lives_ok( sub{ $obj4 = $builder->$getter( values %$id ) },
                  qq{builder getter method finds generated $generated_class} );

        ok( $obj3 eq $obj4,
            qq{and the found object is the latest $generated_class to be instantiated} );
    }
    else {
        dies_ok( sub{ $builder->$getter( values %$id ) },
             qq{builder $generated_class getter method fails for multi-component IDs.} );
    }

    return;
}

# Dummy values for use in tests.
my $dummy_cv = Bio::MAGETAB::ControlledTerm->new(
    'category' => 'test category',
    'value'    => 'test value',
);
my $dummy_ts = Bio::MAGETAB::TermSource->new(
    'name'  => 'test ts name',
);
my $dummy_node1 = Bio::MAGETAB::DataAcquisition->new(
    'name'  => 'node1',
);
my $dummy_node2 = Bio::MAGETAB::DataAcquisition->new(
    'name'  => 'node2',
);
my $dummy_node3 = Bio::MAGETAB::DataAcquisition->new(
    'name'  => 'node3',
);
my $dummy_factor = Bio::MAGETAB::Factor->new(
    'name'  => 'dummy factor',
);
my $dummy_meas = Bio::MAGETAB::Measurement->new(
    'type'  => 'dummy measurement type',
);
my $dummy_rep = Bio::MAGETAB::Reporter->new(
    'name'  => 'dummy reporter',
);

# Hash specifying the tests themselves.
# FIXME objects identified by multiple attributes are not currently provided with a working getter method.
# FIXME this list remains incomplete.
my %test = (
    'array_design'      => { 'class'  => 'Bio::MAGETAB::ArrayDesign',
                             'id'     => { 'name' => 'test name' },
                             'attrs'  => {},
                             'unused' => [ 'not a name' ],
                         },
    'assay'             => { 'class'  => 'Bio::MAGETAB::Assay',
                             'id'     => { 'name'           => 'test name' },
                             'attrs'  => { 'technologyType' => $dummy_cv },
                             'unused' => [ 'not a name' ],
                         },
    # FIXME I suspect the comment methods may be hideously awry. This API may need changing.
#    'comment'           => { 'class'  => 'Bio::MAGETAB::Comment',
#                             'attrs'  => { 'name'  => 'test name',
#                                           'value' => 'test value' },
#                             'unused' => [ 'not a name', 'not a value' ],
#                         },
    'composite_element' => { 'class'  => 'Bio::MAGETAB::CompositeElement',
                             'id'     => { 'name' => 'test name' },
                             'attrs'  => {},
                             'unused' => [ 'not a name' ],
                         },
    'contact'           => { 'class'  => 'Bio::MAGETAB::Contact',
                             'id'     => { 'lastName'    => 'last name',
                                           'firstName'   => 'first name',
                                           'midInitials' => 'mid initials' },
                             'attrs'  => {},
                             'unused' => [ 'a', 'b', 'c' ],
                         },
    'controlled_term'   => { 'class'  => 'Bio::MAGETAB::ControlledTerm',
                             'id'     => { 'category' => 'test cat',
                                           'value'    => 'test value' },
                             'attrs'  => {},
                             'unused' => [ 'x', 'y' ],
                   },
    'data_acquisition'  => { 'class'  => 'Bio::MAGETAB::DataAcquisition',
                             'id'     => { 'name' => 'test name' },
                             'attrs'  => {},
                             'unused' => [ 'not a name' ],
                         },
    'data_file'         => { 'class'  => 'Bio::MAGETAB::DataFile',
                             'id'     => { 'uri'    => 'http://my.test.uri' },
                             'attrs'  => { 'type'   => $dummy_cv,
                                           'format' => $dummy_cv },
                             'unused' => [ 'http://not.my.uri' ],
                         },
    'data_matrix'       => { 'class'  => 'Bio::MAGETAB::DataMatrix',
                             'id'     => { 'uri'  => 'http://my.test.uri' },
                             'attrs'  => { 'type' => $dummy_cv },
                             'unused' => [ 'http://not.my.uri' ],
                         },
    'database_entry'    => { 'class'  => 'Bio::MAGETAB::DatabaseEntry',
                             'id'     => { 'accession'  => 'test accession',
                                           'termSource' => $dummy_ts },
                             'attrs'  => {},
                             'unused' => [ 'not an accession', $dummy_ts ],
                         },
    'edge'              => { 'class'  => 'Bio::MAGETAB::Edge',
                             'id'     => { 'inputNode'  => $dummy_node1,
                                           'outputNode' => $dummy_node2 },
                             'attrs'  => {},
                             'unused' => [ $dummy_node1, $dummy_node3 ],
                         },
    'extract'           => { 'class'  => 'Bio::MAGETAB::Extract',
                             'id'     => { 'name' => 'test name' },
                             'attrs'  => {},
                             'unused' => [ 'not a name' ],
                         },
    'factor'            => { 'class'  => 'Bio::MAGETAB::Factor',
                             'id'     => { 'name' => 'test name' },
                             'attrs'  => {},
                             'unused' => [ 'not a name' ],
                         },
    'factor_value'      => { 'class'  => 'Bio::MAGETAB::FactorValue',
                             'id'     => { 'factor' => $dummy_factor,
                                           'term'   => $dummy_cv },
                             'attrs'  => {},
                             'unused' => [ 'factor'      => $dummy_factor,
                                           'measurement' => $dummy_meas ],
                         },
    'feature'           => { 'class'  => 'Bio::MAGETAB::Feature',
                             'id'     => { 'blockColumn' => 1,
                                           'blockRow'    => 2,
                                           'column'      => 3,
                                           'row'         => 4 },
                             'attrs'  => { 'reporter'    => $dummy_rep },
                             'unused' => [ 4,2,3,1 ],
                         },
    'investigation'     => { 'class'  => 'Bio::MAGETAB::Investigation',
                             'id'     => { 'title' => 'test title' },
                             'attrs'  => {},
                             'unused' => [ 'not a title' ],
                         },
#    '' => { 'class'  => 'Bio::MAGETAB::',
#                             'id'     => { '' => '' },
#                       'attrs'  => { '' => '' },
#                       'unused' => [ '' ],
#                   },
    'publication'       => { 'class'  => 'Bio::MAGETAB::Publication',
                             'id'     => { 'title' => 'test title' },
                             'attrs'  => {},
                             'unused' => [ 'not a title' ],
                         },
);

# FIXME we may want to test more instantiation options.
my $builder;
lives_ok( sub{ $builder = Bio::MAGETAB::Util::Reader::Builder->new({
    namespace => 'test_namespace',
    authority => 'test_authority',
}) }, q{Object constructor succeeds} );
ok( defined $builder, q{and returns an object} );
ok( $builder->isa('Bio::MAGETAB::Util::Reader::Builder'), q{of the correct class} );

while ( my ( $method, $data ) = each %test ) {

    confirm_method( $builder,
                    $method,
                    $data->{'class'},
                    $data->{'id'},
                    $data->{'attrs'} );

    if ( scalar @{ $data->{'unused'} } && (scalar keys %{ $data->{'id'} } == 1) ) {
        my $getter = "get_$method";
        dies_ok( sub{ $builder->$getter( @{ $data->{'unused'} } ) },
                 qq{builder still fails to find non-existent $data->{class} object} );
    }
}
